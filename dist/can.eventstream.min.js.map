{"version":3,"file":"can.eventstream.min.js","sources":["webpack/universalModuleDefinition","can.eventstream.min.js","webpack/bootstrap 12c376dcda6f4a2d54f4*","./src/index.js","external \"can\"*"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","MapChangeEvent","args","event","which","how","value","oldValue","ListChangeEvent","type","index","isNaN","Error","syncAsMap","map","val","key","hasOwnProperty","attr","removeAttr","removeOthers","undefined","console","warn","syncAsList","list","isMapEvent","length","splice","apply","concat","replace","howMany","can","oldBind","bind","ev","cb","EventStream","oldDelegate","delegate","selector","arguments","oldUnbind","unbind","handler","isEventStream","___unbinders","oldBindAndSetup","bindAndSetup","oldUnbindAndTeardown","unbindAndTeardown","oldControlOn","Control","prototype","on","ctx","eventName","func","untilStream","element","Map","oldCanMapBind","getEventValueForStream","target","_data","off","List","_type","bindComputeFromStream","stream","compute","push","onValue","bindMapFromStream","bindListFromStream"],"mappings":"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","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"can\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"can\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"can\")) : factory(root[\"can\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn ","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"can\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"can\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"can\")) : factory(root[\"can\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/ \t\t\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/ \t\t\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/ \t\t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/******/ \t\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/ \t\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/ \t\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/ \t\n/******/ \t\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\n\tvar __moduleName = \"src/index\";\n\tvar can = __webpack_require__(1);\n\tvar oldBind = can.bind;\n\tcan.bind = function(ev, cb) {\n\t  if (cb) {\n\t    return oldBind.call(this, ev, cb);\n\t  } else {\n\t    return can.EventStream.bind(this, ev || \"change\");\n\t  }\n\t};\n\tvar oldDelegate = can.delegate;\n\tcan.delegate = function(selector, ev, cb) {\n\t  if (cb) {\n\t    return oldDelegate.apply(this, arguments);\n\t  } else {\n\t    return can.EventStream.bind(this, ev || \"change\", selector);\n\t  }\n\t};\n\tvar oldUnbind = can.unbind;\n\tcan.unbind = function(ev, handler) {\n\t  if (!handler && can.EventStream.isEventStream(ev)) {\n\t    if (this.___unbinders) {\n\t      for (var i = 0; i < this.___unbinders.length; i++) {\n\t        if (this.___unbinders[i][0] === ev) {\n\t          this.___unbinders[i][1]();\n\t          this.___unbinders.splice(i, 1);\n\t          break;\n\t        }\n\t      }\n\t    }\n\t    return this;\n\t  } else {\n\t    return oldUnbind.apply(this, arguments);\n\t  }\n\t};\n\tvar oldBindAndSetup = can.bindAndSetup;\n\tcan.bindAndSetup = function(ev, cb) {\n\t  return cb ? oldBindAndSetup.apply(this, arguments) : can.bind.call(this, ev);\n\t};\n\tvar oldUnbindAndTeardown = can.unbindAndTeardown;\n\tcan.unbindAndTeardown = function(ev, cb) {\n\t  if (!cb && can.EventStream.isEventStream(ev)) {\n\t    return can.unbind.call(this, ev);\n\t  } else {\n\t    return oldUnbindAndTeardown.apply(this, arguments);\n\t  }\n\t};\n\tvar oldControlOn = can.Control.prototype.on;\n\tcan.Control.prototype.on = function(ctx, selector, eventName, func) {\n\t  if (!ctx) {\n\t    return oldControlOn.apply(this, arguments);\n\t  }\n\t  if (can.EventStream.isEventStream(ctx)) {\n\t    return can.EventStream.untilStream(ctx, can.bind.call(this, \"destroyed\"));\n\t  } else {\n\t    if (typeof ctx === \"string\") {\n\t      func = eventName;\n\t      eventName = selector;\n\t      selector = ctx;\n\t      ctx = this.element;\n\t    }\n\t    if (func === undefined) {\n\t      func = eventName;\n\t      eventName = selector;\n\t      selector = null;\n\t    }\n\t    if (eventName == null) {\n\t      eventName = \"change\";\n\t    }\n\t    if (!func || (typeof func === \"string\" && !this[func])) {\n\t      return can.EventStream.untilStream(selector ? can.bind.call(ctx, eventName) : can.delegate.call(ctx, selector, eventName), can.bind.call(this, \"destroyed\"));\n\t    } else {\n\t      return oldControlOn.apply(this, arguments);\n\t    }\n\t  }\n\t};\n\tcan.Map.bind = can.Map.on = can.bindAndSetup;\n\tvar oldCanMapBind = can.Map.prototype.bind;\n\tcan.Map.prototype.bind = function() {\n\t  var ev = arguments[0] !== (void 0) ? arguments[0] : \"change\";\n\t  var cb = arguments[1];\n\t  return oldCanMapBind.call(this, ev, cb);\n\t};\n\tcan.Map.prototype.getEventValueForStream = function(args) {\n\t  switch (args[0] && args[0].type) {\n\t    case \"change\":\n\t      return new MapChangeEvent(args);\n\t    default:\n\t      var target = args[0].target;\n\t      if (target._data && target._data.hasOwnProperty(args[0].type)) {\n\t        return args[1];\n\t      } else {\n\t        return args;\n\t      }\n\t  }\n\t};\n\tcan.Map.unbind = can.Map.off = can.unbindAndTeardown;\n\tvar oldCanMapUnbind = can.Map.prototype.unbind;\n\tcan.Map.prototype.unbind = function(ev, cb) {\n\t  if (!cb && can.EventStream.isEventStream(ev)) {\n\t    return can.unbind.call(this, ev);\n\t  } else {\n\t    return oldCanMapBind.apply(this, arguments);\n\t  }\n\t};\n\tfunction MapChangeEvent(args) {\n\t  this.event = args[0];\n\t  this.which = args[1];\n\t  this.how = args[2];\n\t  this.value = args[3];\n\t  this.oldValue = args[4];\n\t}\n\tcan.List.prototype.getEventValueForStream = function(args) {\n\t  switch (args[0] && args[0].type) {\n\t    case \"change\":\n\t    case \"set\":\n\t    case \"add\":\n\t    case \"remove\":\n\t      return new ListChangeEvent(args);\n\t    case \"length\":\n\t      return args[1];\n\t    default:\n\t      var target = args[0].target;\n\t      var _type = args[0].type;\n\t      if (target.hasOwnProperty(args[0].type)) {\n\t        return isNaN(_type) ? args[1] : args[1][0];\n\t      } else {\n\t        return args;\n\t      }\n\t  }\n\t};\n\tfunction ListChangeEvent(args) {\n\t  this.event = args[0];\n\t  switch (this.event.type) {\n\t    case \"change\":\n\t      this.index = isNaN(args[1]) ? args[1] : +args[1];\n\t      this.how = args[2];\n\t      this.value = this.how === \"remove\" ? args[4] : args[3];\n\t      this.oldValue = args[4];\n\t      break;\n\t    case \"set\":\n\t    case \"add\":\n\t    case \"remove\":\n\t      this.index = args[2];\n\t      this.how = this.event.type;\n\t      this.value = args[1];\n\t      this.oldValue = null;\n\t      break;\n\t    default:\n\t      throw new Error(\"Unexpected can.List event: \" + this.event.type);\n\t  }\n\t}\n\tcan.bindComputeFromStream = function(stream) {\n\t  var compute = arguments[1] !== (void 0) ? arguments[1] : can.compute();\n\t  if (!compute.___unbinders) {\n\t    compute.___unbinders = [];\n\t  }\n\t  compute.___unbinders.push([stream, can.EventStream.onValue(stream, compute)]);\n\t  return compute;\n\t};\n\tcan.bindMapFromStream = function(stream) {\n\t  var map = arguments[1] !== (void 0) ? arguments[1] : new can.Map();\n\t  if (!map.___unbinders) {\n\t    map.___unbinders = [];\n\t  }\n\t  map.___unbinders.push([stream, can.EventStream.onValue(stream, (function(ev) {\n\t    return syncAsMap(map, ev);\n\t  }))]);\n\t  return map;\n\t};\n\tcan.bindListFromStream = function(stream) {\n\t  var list = arguments[1] !== (void 0) ? arguments[1] : new can.List();\n\t  if (!list.___unbinders) {\n\t    list.___unbinders = [];\n\t  }\n\t  list.___unbinders.push([stream, can.EventStream.onValue(stream, (function(ev) {\n\t    return syncAsList(list, ev);\n\t  }))]);\n\t  return list;\n\t};\n\tfunction syncAsMap(map, val) {\n\t  var key = val.hasOwnProperty(\"which\") ? val.which : val.index;\n\t  switch (val.how) {\n\t    case \"set\":\n\t      map.attr(key, val.value);\n\t      break;\n\t    case \"add\":\n\t      map.attr(key, val.value);\n\t      break;\n\t    case \"remove\":\n\t      map.removeAttr(key);\n\t      break;\n\t    case \"replace\":\n\t      map.attr(val.value, val.removeOthers);\n\t      break;\n\t    case undefined:\n\t      console.warn(\"Missing event type on change event: \", val);\n\t      map.attr(val);\n\t      break;\n\t    default:\n\t      console.warn(\"Unexpected event type: \", val.how);\n\t      map.attr(val);\n\t  }\n\t}\n\tfunction syncAsList(list, event) {\n\t  var isMapEvent = event.hasOwnProperty(\"which\") || isNaN(event.index);\n\t  if (isMapEvent && event.how !== \"replace\") {\n\t    syncAsMap(list, event);\n\t  } else {\n\t    switch (event.how) {\n\t      case \"set\":\n\t        list.attr(event.index, event.value);\n\t        break;\n\t      case \"add\":\n\t        if (!event.value || !event.value.length) {\n\t          console.warn(\"'add' events sent to lists must have an array-like as their value\");\n\t        }\n\t        list.splice.apply(list, [event.index, 0].concat([event.value]));\n\t        break;\n\t      case \"remove\":\n\t        list.splice(event.index, event.value ? event.value.length : 1);\n\t        break;\n\t      case \"replace\":\n\t        if (event.hasOwnProperty(\"removeOthers\")) {\n\t          list.attr(event.value, event.removeOthers);\n\t        } else {\n\t          list.replace(event.value);\n\t        }\n\t        break;\n\t      case \"splice\":\n\t        list.splice.apply(list, [event.index, event.howMany].concat(event.value));\n\t        break;\n\t      case undefined:\n\t        console.warn(\"Missing event type on change event: \", event);\n\t        list.replace(event.value);\n\t        break;\n\t      default:\n\t        console.warn(\"Unexpected event type: \", event.how);\n\t        list.replace(event.value);\n\t    }\n\t  }\n\t}\n\t\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }\n/******/ ])\n})\n","\n// The module cache\nvar installedModules = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tif(installedModules[moduleId])\n\t\treturn installedModules[moduleId].exports;\n\t\n\t// Create a new module (and put it into the cache)\n\tvar module = installedModules[moduleId] = {\n\t\texports: {},\n\t\tid: moduleId,\n\t\tloaded: false\n\t};\n\t\n\t// Execute the module function\n\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\t\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = modules;\n\n// expose the module cache\n__webpack_require__.c = installedModules;\n\n// __webpack_public_path__\n__webpack_require__.p = \"\";\n\n\n// Load entry module and return exports\nreturn __webpack_require__(0);","module can from \"can\";\n\n/**\n * @function can.EventStream.isEventStream\n *\n * Must be implemented by a can.eventstream plugin.\n *\n * Returns a truthy value if `stream` is a compatible event stream.\n *\n * @param {EventStream} stream\n * @returns boolean\n */\n\n/**\n * @function can.EventStream.onValue\n *\n * Must be implemented by a can.eventstream plugin.\n *\n * Binds `callback` such that it will be called on `stream` values. Callback\n * invocation will follow the stream's semantics.\n *\n * @param {EventStream} stream\n * @param {Function(Any)} callback - Callback that receives a single event value\n *                                   whenever the stream 'fires'\n *\n * @returns Function() - Calling this function may be used to unbind the\n *                       listener.\n */\n\n/**\n * @function can.EventStream.bind\n *\n * Must be implemented by a can.eventstream plugin.\n *\n * Returns an event stream that will listen to events, using the given\n * parameters.\n *\n * @param context - The context to listen to events on. `can.bind` and\n *                        `can.delegate` may be used.\n * @param selector - Subselector to delegate on, if any.\n * @param event - Name of event to listen to.\n *\n * @returns EventStream\n */\n\n/**\n * @function can.EventStream.untilStream\n *\n * Must be implemented by a can.eventstream plugin.\n *\n * Returns an event stream that will return values until `until` receives a\n * value.\n *\n * @param {EventStream} stream - Stream to return values from.\n * @param {EventStream} until - Stream that will notify when returned stream\n *                              should stop piping data from `stream`\n *\n * @returns EventStream\n */\n\n/**\n * @function #getEventValueForStream\n */\n\nvar oldBind = can.bind;\n/**\n * @function can.bind\n *\n * Extends `can.bind()` such that if it's called with only one argument (the\n * event name), or without any arguments, an `EventStream` object is\n * created, instead of binding a callback to the event.\n *\n * The actual event values sent into the `EventStream` will vary depending on\n * the observed value.\n *\n * See http://canjs.com/docs/can.bind.html for documentation on the default\n * behavior.\n *\n * @param {Any} this - The object to bind events on.\n * @param {String} [event=\"change\"] - Name of event to hook up to\n * @param {Function} [callback] - Callback to invoke when event fires. If this\n *                                parameter is provided, the method will revert\n *                                to its default behavior.\n *\n * @returns EventStream | Any\n *\n * @example\n * can.bind.call(new can.Map(), \"change\")\n * // => Event stream of change events\n *\n */\ncan.bind = function(ev, cb) {\n  if (cb){\n    return oldBind.call(this, ev, cb);\n  } else {\n    return can.EventStream.bind(this, ev || \"change\");\n  }\n};\n\nvar oldDelegate = can.delegate;\n/**\n * @function can.delegate\n *\n * Extends `can.delegate()` such that if it's called with only one or two\n * arguments (the selector, and the event name), an `EventStream` object is\n * created, instead of binding a callback to the event.\n *\n * The actual event values sent into the `EventStream` will vary depending on\n * the observed value.\n *\n * See http://canjs.com/docs/can.delegate.html for documentation on the default\n * behavior.\n *\n * @param {Any} this - The object to bind events on.\n * @param {Any} selector - The selector to delegate to.\n * @param {String} [event=\"change\"] - Name of event to hook up to.\n * @param {Function} [callback] - Callback to invoke when event fires. If this\n *                                parameter is provided, the method will revert\n *                                to its default behavior.\n *\n * @returns EventStream | Any\n *\n * @example\n * can.delegate.call(window, \"a\", \"click\")\n * // => Event stream of click events on <a> elements.\n *\n */\ncan.delegate = function(selector, ev, cb) {\n  if (cb) {\n    return oldDelegate.apply(this, arguments);\n  } else {\n    return can.EventStream.bind(this, ev || \"change\", selector);\n  }\n};\n\nvar oldUnbind = can.unbind;\n/**\n * @function can.unbind\n *\n * Extends `can.unbind()` such that if it's called with an `EventStream` as the\n * event and no handler, it unbinds an attached stream from `this`. Otherwise,\n * it will revert to the default behavior.\n *\n * This override is primarily for the purpose of undoing the effects\n * `can.bind[X]FromStream()` family of functions. Once this function is called,\n * the bound objects will no longer listen for changes from the stream, and the\n * stream will be garbage collectable once again (since binding in this way\n * forces them to actually bind and stick around).\n *\n * See http://canjs.com/docs/can.unbind.html for documentation on the default\n * behavior.\n */\ncan.unbind = function(ev, handler) {\n  if (!handler && can.EventStream.isEventStream(ev)) {\n    if (this.___unbinders) {\n      for (var i = 0; i < this.___unbinders.length; i++) {\n        if (this.___unbinders[i][0] === ev) {\n          this.___unbinders[i][1]();\n          this.___unbinders.splice(i, 1);\n          break;\n        }\n      }\n    }\n    return this;\n  } else {\n    return oldUnbind.apply(this, arguments);\n  }\n};\n\n\n/**\n * @function can.compute#bind\n *\n * Extends the default CanJS behavior of the `can.compute#bind()` method so that\n * it returns an `EventStream` of new `can.compute` values, if no `callback` is\n * provided to the `.bind()` call. If the `callback` is present, this method\n * reverts to the standard behavior of binding an event listener directly.\n *\n * @param {String} [event=\"change\"] - Name of event to hook up to\n * @param {Function} [callback] - Callback to invoke when event fires. If this\n *                                parameter is provided, the method will revert\n *                                to its default behavior.\n *\n * @returns EventStream | Computed\n *\n * @example\n * var compute = can.compute(1);\n * compute.bind().log(\"compute changed\");\n * compute(2);\n * // compute changed 2\n */\n\n/**\n * @function can.compute#unbind\n *\n * See documentation for `can.unbind()`\n */\n\n\nvar oldBindAndSetup = can.bindAndSetup;\n// Mostly internal, but used to replace the `.bind()` behavior for all\n// Observables in Can.\ncan.bindAndSetup = function(ev, cb) {\n  return cb ?\n    oldBindAndSetup.apply(this, arguments) :\n    can.bind.call(this, ev);\n};\n\nvar oldUnbindAndTeardown = can.unbindAndTeardown;\ncan.unbindAndTeardown = function(ev, cb) {\n  if (!cb && can.EventStream.isEventStream(ev)) {\n    return can.unbind.call(this, ev);\n  } else {\n    return oldUnbindAndTeardown.apply(this, arguments);\n  }\n};\n\nvar oldControlOn = can.Control.prototype.on;\n/**\n * @function can.Control#on\n *\n * Enhances `can.Control#on` (and by extension, `can.Component#events#on`) so it\n * can be used to listen to event streams in a memory-safe way, according to the\n * control/component's lifecycle. Since the default method accepts method names,\n * this overridden method will first check if the possible `callback` is an\n * existing property, if it's a string, before determining whether to fall back\n * to the default behavior, or to return an event stream.\n *\n * See http://canjs.com/docs/can.Control.prototype.on.html\n *\n *\n * @param {Any} [context=this.element] - The object to listen for events on.\n * @param {String} [selector] - If provided, the selector to delegate to.\n * @param {String} [event=\"change\"] - The name of the event to listen to.\n * @param {Function|String} [callback] - Callback or method name to invoke when\n *                                       event fires. If this parameter is\n *                                       provided, the method will revert to its\n *                                       default behavior.\n *\n * @returns EventStream | Number\n *\n * @example\n * ...\n * events: {\n *   inserted: function() {\n *     this.on(GlobalStreams.specialEvent).log(\"special event:\");\n *   }\n * }\n * ...\n * $(\"mycomponent\").remove();\n * GlobalStreams.specialEvent.push(\"whatever\"); // Nothing happens\n *\n * // The following are also equivalent:\n * this.on(scope, \"change\");\n * this.on(scope);\n *\n */\ncan.Control.prototype.on = function(ctx, selector, eventName, func) {\n  if (!ctx) {\n    return oldControlOn.apply(this, arguments);\n  }\n  if (can.EventStream.isEventStream(ctx)) {\n    return can.EventStream.untilStream(ctx, can.bind.call(this, \"destroyed\"));\n  } else {\n    if (typeof ctx === \"string\") {\n      func = eventName;\n      eventName = selector;\n      selector = ctx;\n      ctx = this.element;\n    }\n\n    // ...otherwise, set `selector` to null\n    if (func === undefined) {\n      func = eventName;\n      eventName = selector;\n      selector = null;\n    }\n\n    if (eventName == null) {\n      eventName = \"change\";\n    }\n\n    if (!func || (typeof func === \"string\" && !this[func])) {\n      return can.EventStream.untilStream(\n        selector ?\n          can.bind.call(ctx, eventName) :\n          can.delegate.call(ctx, selector, eventName),\n        can.bind.call(this, \"destroyed\"));\n    } else {\n      return oldControlOn.apply(this, arguments);\n    }\n  }\n};\n\n/**\n * @function can.Map#bind\n *\n * Replaces the default CanJS behavior of the `can.Map#bind()` method with one\n * that returns an `EventStream` of event objects or values if the `callback`\n * argument is not provided.\n *\n * The values in `EventStream` vary depending on the event being listened to.\n *\n * For named property events, the new value of the property is returned, as-is.\n *\n * For `\"change\"` events, `MapChangeEvent` objects are returned, with the\n * following properties:\n *\n * {\n *   event: Object // The CanJS event object.\n *   which: String // They attr/key affected by the event,\n *   how: \"add\"|\"remove\"|\"set\" // The type of operation,\n *   value: Any // For \"add\"/\"set\" events, the new value. For \"remove\" events,\n *                 the removed value.\n * }\n *\n * Note that this object fits the API required for `can.toCanMap`, so the\n * `EventStream` returned by this function can be piped into a different\n * `can.Map` to partially or fully synchronise both maps.\n *\n * Additionally, The events from that `Map` changing can then be piped back into\n * the original `Map` without causing circularity issues, achieving two-way\n * binding between both objects. See example.\n *\n * @param {String} [event=\"change\"] - Name of event to hook up to\n * @param {Function} [callback] - Callback to invoke when event fires. If this\n *                                parameter is provided, the method will revert\n *                                to its default behavior.\n *\n * @returns EventStream | `this`\n *\n * @example\n * // Binding\n * var map = new can.Map({x:1});\n * map.bind().log(\"map changed:\");\n * map.bind(\"x\").log(\"x property changed:\");\n * map.attr(\"x\", 2);\n * // map changed: {event: Object, which: \"x\", \"how\": \"set\", value: 2}\n * // x property changed: 2\n *\n * // Piping into a different Map\n * var map1 = new can.Map();\n * var map2 = map1.bind().toCanMap(new can.Map());\n * map1.bind().log(\"map1 changed:\");\n * map2.bind().log(\"map2 changed:\");\n *\n * map1.attr(\"x\", 1);\n * // map2 changed: {event: Object, which: \"x\", \"how\": \"add\", value:1}\n * // map1 changed: {event: Object, which: \"x\", \"how\": \"add\", value:1}\n * map2.attr(\"x\", 2);\n * // map1 changed: {event: Object, which: \"x\", \"how\": \"set\", value:2}\n * // map2 changed: {event: Object, which: \"x\", \"how\": \"set\", value:2}\n * console.log(map1.attr(), map2.attr());\n * // {x:2}, {x:2}\n */\ncan.Map.bind = can.Map.on = can.bindAndSetup;\nvar oldCanMapBind = can.Map.prototype.bind;\ncan.Map.prototype.bind = function(ev=\"change\", cb) {\n  return oldCanMapBind.call(this, ev, cb);\n};\ncan.Map.prototype.getEventValueForStream = function(args) {\n  switch (args[0] && args[0].type) {\n  case \"change\":\n    return new MapChangeEvent(args);\n  default:\n    var target = args[0].target;\n    if (target._data && target._data.hasOwnProperty(args[0].type)) {\n      // We found a named property change event, not a generic custom event\n      // (maybe, probably)\n      return args[1];\n    } else {\n      // If we don't know what the event is, return the arguments as-is\n      return args;\n    }\n  }\n};\n\n/**\n * @function can.Map#unbind\n *\n * See documentation for `can.unbind()`\n */\ncan.Map.unbind = can.Map.off = can.unbindAndTeardown;\nvar oldCanMapUnbind = can.Map.prototype.unbind;\ncan.Map.prototype.unbind = function(ev, cb) {\n  if (!cb && can.EventStream.isEventStream(ev)) {\n    return can.unbind.call(this, ev);\n  } else {\n    return oldCanMapBind.apply(this, arguments);\n  }\n};\n\nfunction MapChangeEvent(args) {\n  this.event = args[0];\n  this.which = args[1];\n  this.how = args[2];\n  this.value = args[3];\n  // This isn't documented because I want to pretend it doesn't exist :)\n  this.oldValue = args[4];\n}\n\n/**\n * @function can.List#bind\n *\n * Replaces the default CanJS behavior of the `can.List#bind()` method with one\n * that returns an `EventStream` of event objects or values if the `callback`\n * argument is not provided.\n *\n * The values in `EventStream` vary depending on the event being listened to.\n *\n * For named property events, the new value of the property is returned,\n * as-is. Both numerical properties (indices) and regular Map attrs can be\n * bound to.\n *\n * For the `\"length\"` events, the new length of the array is returned as-is.\n *\n * The rest of the events, namely `\"change\"`, `\"add\"`, `\"remove\"`, and `\"set\"`,\n * either `ListChangeEvent` or `MapChangeEvent` objects are returned from the\n * stream, depending on whether the modification involves a numerical key.\n\n * For events on numerical properties, `ListChangeEvent` objects are returned,\n * with the following properties:\n *\n * {\n *   event: Object // The CanJS event object.\n *   index: Integer // They initial index of the change.\n *   how: \"add\"|\"remove\"|\"set\" // The type of operation,\n *   value: Array | Any // For \"add\" events, an array of added items.\n *                         For \"remove\" events, an array of removed items.\n *                         For \"set\", the single new value.\n * }\n *\n * For events on non-numerical properties, `MapChangeEvent` objects are\n * returned, using the same structure as `can.Map#bind()`:\n *\n * {\n *   event: Object // The CanJS event object.\n *   which: String // They attr/key affected by the event,\n *   how: \"add\"|\"remove\"|\"set\" // The type of operation,\n *   value: Array // For \"add\"/\"set\" events, the new values. For \"remove\" events,\n *                // the removed values.\n * }\n *\n * Note that these objects conform to the API required for\n * `can.bindListFromStream` and `can.bindMapFromStream` respectively, so the\n * `EventStream` returned by this function can be piped into a different\n * `can.List` or `can.Map` to synchronise both.\n *\n * Unlike the stream returned by `can.Map#bind()`, this one cannot be used for\n * two-way binding out of the box, since `add` events will bounce back and forth\n * infinitely and cause an overflow. One-way binding works fine, though, and can\n * easily handle lists of different lengths.\n *\n * @param {String} [event=\"change\"] - Name of event to hook up to\n * @param {Function} [callback] - Callback to invoke when event fires. If this\n *                                parameter is provided, the method will revert\n *                                to its default (non-`can.bacon`) behavior.\n *\n * @returns EventStream | `this`\n *\n */\ncan.List.prototype.getEventValueForStream = function(args) {\n  switch (args[0] && args[0].type) {\n  case \"change\":\n  case \"set\":\n  case \"add\":\n  case \"remove\":\n    return new ListChangeEvent(args);\n  case \"length\":\n    return args[1];\n  default:\n    // This is different from the can.Map version because can.Lists don't have\n    // the _data property.\n    var target = args[0].target;\n    var _type = args[0].type;\n    if (target.hasOwnProperty(args[0].type)) {\n      // We found a named property change event, not a generic custom event\n      // (maybe, probably).\n      // TODO - change the semantics here to check for integers. Floats should\n      // be treated as string keys.\n      return isNaN(_type) ? args[1] : args[1][0];\n    } else {\n      // If we don't know what the event is, return the arguments as-is\n      return args;\n    }\n  }\n};\n\n/**\n * @function can.List#unbind\n *\n * See documentation for `can.unbind()`\n */\n\nfunction ListChangeEvent(args) {\n  this.event = args[0];\n  switch (this.event.type) {\n  case \"change\":\n    // NOTE: This gets a string as the index for all change events.\n    this.index = isNaN(args[1])?args[1]:+args[1];\n    this.how = args[2];\n    // We take the liberty of changing these semantics for remove events. Aside\n    // from it being generally more convenient for filtering, this means that,\n    // aside from `this.oldValue` being weird, binding to \"change\" and filtering\n    // on `how` will give exactly equivalent results to just binding directly on\n    // the specific event type.\n    //\n    // NOTE: when you `can.List#pop()` on an empty array, you get\n    // `[undefined]` as the value, whereas splicing an empty array gets you\n    // `[]` as the value.\n    // See https://github.com/bitovi/canjs/issues/998\n    this.value = this.how === \"remove\" ? args[4] : args[3];\n    // This is only ever of interest for set events (we never spit out\n    // ListChangeEvent for length events)\n    this.oldValue = args[4];\n    break;\n  case \"set\":\n  case \"add\":\n  case \"remove\":\n    this.index = args[2];\n    this.how = this.event.type;\n    // NOTE: The docs say that this can be either one, or many things. I can\n    // only seem to get arrays out of this event, though.\n    this.value = args[1];\n    // NOTE: These events do not include oldValue.\n    this.oldValue = null;\n    break;\n  default:\n    throw new Error(\"Unexpected can.List event: \"+this.event.type);\n  }\n}\n\n/**\n * Returns a `can.compute` whose value changes whenever `stream` has a new value\n * If a compute is provided, it will be used instead of creating a new one.\n */\ncan.bindComputeFromStream = function(stream, compute=can.compute()) {\n  if (!compute.___unbinders) { compute.___unbinders = []; }\n  compute.___unbinders.push([stream, can.EventStream.onValue(stream, compute)]);\n  return compute;\n};\n\n/**\n * Returns a `can.Map` whose value is managed by a stream of incoming map change\n * events.\n *\n * If `map` is provided, it *must* be a `can.Map` instance (or an instance of a\n * subclass), which will be used instead of creating a new empty `can.Map`.\n *\n * Two kinds of event objects are accepted:\n *\n * @example\n * // Modification event. Modifies a single key.\n * {\n *   how: \"set\"|\"add\"|\"remove\", // The type of operation.\n *   which: String, // The key to modify.\n *   value: Any, // The value to set. Optional for `remove`.\n * }\n *\n * // Replacement event. Uses `.attr()` to replace multiple keys.\n * {\n *   how: \"replace\", // Must be this string.\n *   value: Object, // Object to replace with.\n *   removeOthers: Boolean // Passed to `.attr()`. See http://canjs.com/docs/can.Map.prototype.attr.html#sig_map_attr_obj__removeOthers__\n * }\n */\ncan.bindMapFromStream = function(stream, map=new can.Map()) {\n  if (!map.___unbinders) { map.___unbinders = []; }\n  map.___unbinders.push([\n    stream,\n    can.EventStream.onValue(stream, (ev) => syncAsMap(map, ev))\n  ]);\n  return map;\n};\n\n/**\n * Returns a `can.List` whose value is managed by a stream of incoming list\n * and/or map change events.\n *\n * If `list` is provided, it *must* be a `can.List` instance, which will be used\n * instead of creating a new empty instance.\n *\n * Three kinds of event objects are accepted:\n *\n * @example\n * // Modification event. Modifies a single index or key.\n * {\n *   how: \"set\"|\"add\"|\"remove\", // The type of operation.\n *   which|index: String|Integer, // The key to modify.\n *   value: Array-like, // The value to set. For \"add\" on an Integer index, must be an\n *                      // Array-like. Optional for `remove`.\n * }\n *\n * // Replacement event. Calls `.replace()`\n * {\n *   how: \"replace\", // Must be this string.\n *   value: Array-like, // Array-like to replace contents with.\n *   removeOthers: Boolean=true (optional) // Whether to keep trailing elements\n *                                            after value has been applied. If\n *                                            this argument is provided, the\n *                                            list will be replaced using\n *                                            `.attr()`. Otherwise, `.replace()`\n *                                            will be used. See:\n *                                            http://canjs.com/docs/can.List.prototype.attr.html#sig_list_attr_elements__replaceCompletely__\n * }\n */\ncan.bindListFromStream = function(stream, list=new can.List()) {\n  if (!list.___unbinders) { list.___unbinders = []; }\n  list.___unbinders.push([\n    stream,\n    can.EventStream.onValue(stream, (ev) => syncAsList(list, ev))\n  ]);\n  return list;\n};\n\nfunction syncAsMap(map, val) {\n  var key = val.hasOwnProperty(\"which\") ? val.which : val.index;\n  switch (val.how) {\n  case \"set\":\n    map.attr(key, val.value);\n    break;\n  case \"add\":\n    map.attr(key, val.value);\n    break;\n  case \"remove\":\n    map.removeAttr(key);\n    break;\n  case \"replace\":\n    map.attr(val.value, val.removeOthers);\n    break;\n  case undefined:\n    console.warn(\"Missing event type on change event: \", val);\n    map.attr(val);\n    break;\n  default:\n    console.warn(\"Unexpected event type: \", val.how);\n    // idk you're giving it to me so I'll shove it in. It's your own fault\n    // if it breaks. You voided the warranty. Be thankful for the log :)\n    map.attr(val);\n  }\n}\n\nfunction syncAsList(list, event) {\n  var isMapEvent = event.hasOwnProperty(\"which\") || isNaN(event.index);\n  if (isMapEvent && event.how !== \"replace\") {\n    syncAsMap(list, event);\n  } else {\n    switch (event.how) {\n    case \"set\":\n      list.attr(event.index, event.value);\n      break;\n    case \"add\":\n      // TODO - tag lists and/or events with some magical number (like.. a\n      // batchnum-style thing) to prevent circular additions when two-way\n      // binding. Please name it: \"___PRAISE_THE_SUN___\"\n      if (!event.value || !event.value.length) {\n        console.warn(\"'add' events sent to lists must have an array-like as their value\");\n      }\n      list.splice.apply(list, [event.index, 0].concat([event.value]));\n      break;\n    case \"remove\":\n      list.splice(event.index,\n                  event.value ? event.value.length : 1);\n      // list.splice(Math.min(val.index, !list.length?0:list.length-1),\n      //             event.value ? event.value.length : 1);\n      break;\n    case \"replace\":\n      if (event.hasOwnProperty(\"removeOthers\")) {\n        list.attr(event.value, event.removeOthers);\n      } else {\n        list.replace(event.value);\n      }\n      break;\n    case \"splice\":\n      list.splice.apply(list, [event.index, event.howMany].concat(event.value));\n      break;\n    case undefined:\n      console.warn(\"Missing event type on change event: \", event);\n      list.replace(event.value);\n      break;\n    default:\n      console.warn(\"Unexpected event type: \", event.how);\n      // idk you're giving it to me so I'll shove it in. It's your own fault\n      // if it breaks. You voided the warranty. Be thankful for the log :)\n      list.replace(event.value);\n    }\n  }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;"],"sourceRoot":"webpack-module://"}